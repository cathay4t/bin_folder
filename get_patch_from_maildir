#!/usr/bin/python2
#Copyright (C) 2014  Gris Ge <cnfourt@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import mailbox
import os
import re
import argparse

def reference_ids_of_message(message):
    if message['References']:
        return re.split('[\n\t]+', message['References'])
    else:
        return []

def subject_of_message(message):
    # Subject might have \n \t, we replace them as one space.
    # http://www.w3.org/Protocols/rfc822/3_Lexical.html#z1
    subject = message['Subject'].replace('\n\t', ' ')
    subject = subject.replace('\n', ' ')
    subject = subject.replace('\t', ' ')
    return subject

def subject_to_filename(subject):
    regex_subject = re.compile(".* ([0-9]+)/[0-9]+\] (.+)$")
    match = regex_subject.match(subject)
    patch_number = None
    patch_name = None
    if match:
        patch_number = int(match.group(1))
        patch_name = match.group(2)
    elif '[PATCH]' in subject:
        # It might a single patch.
        patch_number = 1
        patch_name = re.sub('.+\[PATCH\] ', '', subject)
    else:
        raise Exception(
            "Failed to do regex parse again 'subject' %s" % subject)

    patch_name = re.sub('[^a-zA-Z0-9\._ ]', '', patch_name)
    patch_name = re.sub(' +', '-', patch_name)

    return "%04d-%s.patch" % (patch_number, patch_name)

def save_to_file(message):
    """
    Save a email to file named as 000x-xxxxxx.patch
    """
    subject = subject_of_message(message)
    file_name = subject_to_filename(subject)
    fd = open(file_name, 'w')
    # If prorblem found, switch to email.generator.Generator.flatten()
    fd.write(message.as_string())
    fd.close()
    print file_name

def main():
    parser = argparse.ArgumentParser(description='Extract patch from maildir')

    parser.add_argument('--maildir', dest='maildir', action='store',
                        required=True,
                        help='Path to the folder of maildir')
    parser.add_argument('--subject', dest='subject', action='store',
                        help='Subject of email for first patch')
    parser.add_argument('--msg-id', dest='msg_id', action='store',
                        help='Message ID of first patch')

    cmd_opt = parser.parse_args(sys.argv[1:])

    if not cmd_opt.msg_id and not cmd_opt.subject:
        print "FAIL: You need to specify --msg-id or --subject"
        cmd_opt.print_help()
        exit(1)

    if cmd_opt.msg_id and cmd_opt.subject:
        print "FAIL: --msg-id is conflict with --subject, just keep one"
        parser.print_help()
        exit(1)

    maildir_path = cmd_opt.maildir

    md_obj = mailbox.Maildir(maildir_path, factory=None, create=False)

    root_message_id = None
    got_messages = []

    if cmd_opt.msg_id:
        root_message_id = cmd_opt.msg_id
        if not re.search('\@', root_message_id):
            print "FAIL: Got invalid message id defined in --msg-id"
            exit(1)
    else:
        for message in md_obj.values():
            cur_subject = subject_of_message(message)

            if not re.match('^\[', cur_subject):
                continue

            if cmd_opt.subject in cur_subject:
                root_message_id = message['Message-Id']
                break

    for message in md_obj.values():
        cur_subject = subject_of_message(message)

        if not re.match('^\[', cur_subject):
            continue

        if root_message_id == message['Message-Id']:
            got_messages.append(message)
            continue

        if root_message_id in reference_ids_of_message(message):
            got_messages.append(message)
            continue

    got_messages = sorted(got_messages, key=lambda msg: msg['Subject'])

    for message in got_messages:
        save_to_file(message)

main()
